<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Spongecaptain 的个人技术博客</title>
    <link>https://spongecaptain.cool/</link>
    <description>Recent content on Spongecaptain 的个人技术博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Spongecaptain</copyright>
    <lastBuildDate>Mon, 17 Jan 2022 14:53:27 +0800</lastBuildDate><atom:link href="https://spongecaptain.cool/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go 中的变量命名</title>
      <link>https://spongecaptain.cool/post/go/names/</link>
      <pubDate>Mon, 17 Jan 2022 14:53:27 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/go/names/</guid>
      <description>来自 Google 的 Andrew Gerrand 曾经关于 Go 中的参数命名规范进行了分享，slides 为 https://talks.golang.org/2014/names.slide 命名习惯很重要 良好的可读性是高质量代码的要求之一 良好的命名习惯有助于提高代</description>
    </item>
    
    <item>
      <title>五分钟理解软件架构模式（译文）</title>
      <link>https://spongecaptain.cool/post/patterndesign/software-architecture-patterns-5-mins-read/</link>
      <pubDate>Fri, 14 Jan 2022 11:58:07 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/patterndesign/software-architecture-patterns-5-mins-read/</guid>
      <description>说明：本文翻译于：Software Architecture Patterns: 5 minute read 当一个人深入软件工程的世界时，总有一天他需要学习软件架构模式的基础知识。当我刚开始编码的时候，我</description>
    </item>
    
    <item>
      <title>《自己动手写Java虚拟机》- 读后摘要</title>
      <link>https://spongecaptain.cool/post/java/implementjvmbygolang/</link>
      <pubDate>Sun, 24 Oct 2021 17:46:05 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/java/implementjvmbygolang/</guid>
      <description>1. 背景介绍 《自己动手写Java虚拟机》一书介绍了如何基于 Go 语言来编写一个 Java 虚拟机。该书对于想通过实践了解 Java 字节码格式、Java 虚拟机实现思路</description>
    </item>
    
    <item>
      <title>一个开源的时间轮算法介绍</title>
      <link>https://spongecaptain.cool/post/widget/timingwheel2/</link>
      <pubDate>Sat, 28 Aug 2021 17:50:41 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/widget/timingwheel2/</guid>
      <description>1. 回顾：简单的时间轮算法 这是我介绍时间轮算法第一篇文章：时间轮算法。本文会基于上一篇文章进行扩展，给出代码，解决一些问题。这也算是对第一篇文</description>
    </item>
    
    <item>
      <title>Go 语言下基于 Redis 的分布式锁</title>
      <link>https://spongecaptain.cool/post/go/redislock/</link>
      <pubDate>Sun, 27 Jun 2021 12:28:17 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/go/redislock/</guid>
      <description>项目地址：https://github.com/Spongecaptain/redisLock 1. Go 原生的互斥锁 Go 原生的互斥锁即 sync 包下的 Mutex 结构</description>
    </item>
    
    <item>
      <title>写给 Java 程序员的 Go Web 框架 Gin 源码入门</title>
      <link>https://spongecaptain.cool/post/gin/introductionofginforjavaer/</link>
      <pubDate>Wed, 19 May 2021 16:50:11 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/gin/introductionofginforjavaer/</guid>
      <description>本文会比较 Gin 与 Netty 以及 Spring 在一些设计上的异同。如果你没有 Java 开发经验，也完全可以略去对比 Java 的部分内容，并不影响理解本文。 1. Gin 启动过程过程概述 下面是</description>
    </item>
    
    <item>
      <title>MySQL join 学习</title>
      <link>https://spongecaptain.cool/post/mysql/joininmysql/</link>
      <pubDate>Sun, 02 May 2021 23:32:23 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/mysql/joininmysql/</guid>
      <description>1. 数学基础：笛卡尔乘积 笛卡尔乘积是一个数学概念： 笛卡尔乘积是指在数学中，两个集合 X 和 Y 的笛卡尔积（Cartesian product），又称直</description>
    </item>
    
    <item>
      <title>Java 强引用、软引用、弱引用以及虚引用</title>
      <link>https://spongecaptain.cool/post/java/referenceinjava/</link>
      <pubDate>Sun, 28 Mar 2021 15:07:50 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/java/referenceinjava/</guid>
      <description>1. Java 中的强引用、软引用、弱引用、虚引用 Java 中强引用、软引用、弱引用、虚引用用于控制堆内实例被回收时的特性，如下表所示： 引用类型 回收时机 强引用 StrongReference</description>
    </item>
    
    <item>
      <title>Netty 的 Sharable 注解</title>
      <link>https://spongecaptain.cool/post/netty/sharableannotationinnetty/</link>
      <pubDate>Sun, 28 Feb 2021 11:22:24 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/netty/sharableannotationinnetty/</guid>
      <description>1. 我向 Apache Dubbo 提的一个 PR 我为 Apache Dubbo 提了如下的一个 PR，试图为 Telnet 通信模式提供一个 Idle 连接计时关闭特性。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24</description>
    </item>
    
    <item>
      <title>逻辑日志与物理日志</title>
      <link>https://spongecaptain.cool/post/database/logicalandphicallog/</link>
      <pubDate>Wed, 17 Feb 2021 10:11:57 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/database/logicalandphicallog/</guid>
      <description>Thanks to Prof. Dr. Jens Dittrich&amp;rsquo;s teaching video. 日志主要分为逻辑日志以及物理日志： 逻辑日志 Logic log[1]； 物理日志 Physical log[2]； 1. 物理日志与逻辑日志的存储内容 1.1 Physical Logging 物理日</description>
    </item>
    
    <item>
      <title>MySQL 的零拷贝技术</title>
      <link>https://spongecaptain.cool/post/mysql/zerocopyofmysql/</link>
      <pubDate>Tue, 16 Feb 2021 11:08:38 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/mysql/zerocopyofmysql/</guid>
      <description>1. Buffer 与 cache 的区别？ Bbuffer 与 Cache 非常类似，因为它们都用于存储数据数据，被应用层读取字节数据。在很多场合它们有着相同的概念，但是特定场合也有一定的区别[</description>
    </item>
    
    <item>
      <title>分布式组件的 WAL 与 fsync</title>
      <link>https://spongecaptain.cool/post/distributedsystem/walandfsync/</link>
      <pubDate>Thu, 28 Jan 2021 11:34:06 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/distributedsystem/walandfsync/</guid>
      <description>1. WAL 与 fsync 1.1 WAL WAL = Write-Ahead Logging，即预写日志。 我们可以将数据库、分布式组件当做状态机，读操作负责读取组件状态，但是写操作并不直接对应于状态的</description>
    </item>
    
    <item>
      <title>向我的 RPC 框架引入负载均衡组件</title>
      <link>https://spongecaptain.cool/post/rpc/addloadbalanceintorpc/</link>
      <pubDate>Wed, 06 Jan 2021 15:49:22 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/rpc/addloadbalanceintorpc/</guid>
      <description>1. 负载均衡是在说一件什么事情？ 下图引用自知乎：什么是负载均衡？，很好地说明了负载均衡是一件什么事情： 取自 WiKi： 负载平衡（Load bala</description>
    </item>
    
    <item>
      <title>Kafka 的高性能的源头</title>
      <link>https://spongecaptain.cool/post/kafka/why-kafka-is-high-performance/</link>
      <pubDate>Wed, 30 Dec 2020 22:03:10 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/kafka/why-kafka-is-high-performance/</guid>
      <description>1. Kafka 持久化的秘密 无论是操作系统还是作为应用程序的 Kafka，都试图提供一个高效的写 API。我们这里分为多个部分对 Kafka 高效持久化（写操作会触发持</description>
    </item>
    
    <item>
      <title>Kafka 的总体框架</title>
      <link>https://spongecaptain.cool/post/kafka/frameworkofkafka/</link>
      <pubDate>Thu, 24 Dec 2020 23:14:29 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/kafka/frameworkofkafka/</guid>
      <description>Kafka 总体框架如上图所示，但是为了更好地理解，我们可以把 Kafka 中的各个组件按照逻辑以及物理进行划分，如下： 逻辑上的概念： Producer：消息生产者</description>
    </item>
    
    <item>
      <title>时间轮算法</title>
      <link>https://spongecaptain.cool/post/widget/timingwheel/</link>
      <pubDate>Sun, 29 Nov 2020 15:48:57 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/widget/timingwheel/</guid>
      <description>时间轮算法 1. 基于队列的定时任务执行模型缺陷 在计算机世界中，只有待解决的问题变得大规模后，算法的价值才能够最大化的体现。时间轮算法可以将插入和</description>
    </item>
    
    <item>
      <title>日志开源项目 FLogger 的设计思路解析</title>
      <link>https://spongecaptain.cool/post/opensource/designofflogger/</link>
      <pubDate>Sat, 21 Nov 2020 23:27:47 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/opensource/designofflogger/</guid>
      <description>项目地址：https://github.com/cyfonly/FLogger 为什么要学习一个开源日志框架 FLogger？ 首先，日志非常重要</description>
    </item>
    
    <item>
      <title>我的 RPC 框架设计</title>
      <link>https://spongecaptain.cool/post/rpc/myrpcframework/</link>
      <pubDate>Sun, 15 Nov 2020 15:53:59 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/rpc/myrpcframework/</guid>
      <description>个人项目地址：https://github.com/Spongecaptain/RPCFramework，欢迎 star&amp;amp;fork。 1.</description>
    </item>
    
    <item>
      <title>Java 并发包的设计框架</title>
      <link>https://spongecaptain.cool/post/java/frameworkofjuc/</link>
      <pubDate>Tue, 10 Nov 2020 21:38:28 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/java/frameworkofjuc/</guid>
      <description>事实上，理解 J.U.C 包的难点之一在于理解包的设计结构以及依赖关系，然而却鲜有此类文章，故写此文。不过需要注意，本文限于篇幅，并不会对某一个细节知识</description>
    </item>
    
    <item>
      <title>Spring XML schema 扩展机制</title>
      <link>https://spongecaptain.cool/post/spring/spring_xml_schema/</link>
      <pubDate>Thu, 29 Oct 2020 22:17:32 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/spring/spring_xml_schema/</guid>
      <description>1. 基于 Spring 容器的 Dubbo Dubbo 采用 Spring 的方式进行组件的管理，支持 XML 以及注解式的配置。在使用时，我们仅仅需要通过 beanName 向 IoC 容器索要组件，IoC 容器就能够返回封装</description>
    </item>
    
    <item>
      <title>人工智能的魔力-AI 真的有如此大的价值吗？</title>
      <link>https://spongecaptain.cool/post/life/thevalueofaitocompany/</link>
      <pubDate>Sun, 25 Oct 2020 15:18:00 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/life/thevalueofaitocompany/</guid>
      <description>我为什么会写这篇文章？ 我的人工智能水平局限于看过周志华的西瓜书，甚至连书本的基础知识都还没有掌握完全。万幸，我至少知道 AI 是怎么一回事。 另一方</description>
    </item>
    
    <item>
      <title>Netty 如何实现自己的解码器与解码器</title>
      <link>https://spongecaptain.cool/post/netty/howtowriteadecoderandencoder/</link>
      <pubDate>Sat, 24 Oct 2020 22:11:20 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/netty/howtowriteadecoderandencoder/</guid>
      <description>Netty 如何实现自己的解码器与解码器 建议首先理解 Netty 的 ChannelPipeline 管道执行模型。 本文的部分代码案例来自于如下开源项目：https://github.com/S</description>
    </item>
    
    <item>
      <title>在实验室服务器部署 GitLab</title>
      <link>https://spongecaptain.cool/post/life/deploygitlab/</link>
      <pubDate>Fri, 02 Oct 2020 20:59:57 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/life/deploygitlab/</guid>
      <description>在实验室服务器部署 GitLab 1. 起因 我为什么觉得实验室代码管理很重要？ 我是北京邮电大学的一名研究生，所处实验室在代码开发上的人数有 10 人左右（主要是部分</description>
    </item>
    
    <item>
      <title>Java 网络编程</title>
      <link>https://spongecaptain.cool/post/java/javanet/</link>
      <pubDate>Sun, 13 Sep 2020 22:14:03 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/java/javanet/</guid>
      <description>Java 网络编程 Java 网络编程大致可以分为三类： 基于 OIO 的阻塞 Socket 与 ServerSocket 编程模型； 基于 NIO 的非阻塞 SocketChannel 与 ServerSocketChannel 编程模型； 对于 JDK NIO 进行二次封装的非阻塞编程框架：Net</description>
    </item>
    
    <item>
      <title>ZooKeeper Watch 机制源码解析</title>
      <link>https://spongecaptain.cool/post/zookeeper/zookeeperwatch/</link>
      <pubDate>Thu, 10 Sep 2020 20:07:03 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/zookeeper/zookeeperwatch/</guid>
      <description>1. ZooKeeper Watch 概述 ZooKeeper Watch 机制类似于 Java 设计模式中的观察者模式或者监听模式，唯一的不同是不再基于线程间通信，而是基于进程间通信。 ZooKeeper Watch 机制是指，客户端在所有</description>
    </item>
    
    <item>
      <title>ZooKeeper 服务端线程分析</title>
      <link>https://spongecaptain.cool/post/zookeeper/zookeeperserverthreadmodel/</link>
      <pubDate>Sun, 06 Sep 2020 22:25:56 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/zookeeper/zookeeperserverthreadmodel/</guid>
      <description>我对 ZooKeeper release-3.6.1 的源码分析地址为：https://github.com/Spongecaptain/zookeeper Enjoy the Source Code. :) 1. 为什么从线程分析入</description>
    </item>
    
    <item>
      <title>ZooKeeper 的个人理解与总结</title>
      <link>https://spongecaptain.cool/post/zookeeper/myunderstandingofzookeeper/</link>
      <pubDate>Tue, 25 Aug 2020 19:56:06 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/zookeeper/myunderstandingofzookeeper/</guid>
      <description>1. ZAB 协议的核心是什么？ 其次，如果不考虑 Zookeeper 基于分布式共识算法的实现细节，我们可以将 Zookeeper 理解为文件系统 + 监听通知机制。 Zookeeper = 文件系统 + 监听通知机制 Zookeeper</description>
    </item>
    
    <item>
      <title>Bigtable 论文阅读</title>
      <link>https://spongecaptain.cool/post/paper/bigtable/</link>
      <pubDate>Fri, 14 Aug 2020 12:20:10 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/paper/bigtable/</guid>
      <description>1. Bigtable 是什么？ Bigtable 是一种压缩的、高性能的、高可扩展性的，基于 Google 文件系统（Google File System，GFS）的数据存储系统，用于存储大规模结构化</description>
    </item>
    
    <item>
      <title>Google File System-GFS 论文阅读</title>
      <link>https://spongecaptain.cool/post/paper/googlefilesystem/</link>
      <pubDate>Wed, 05 Aug 2020 10:56:59 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/paper/googlefilesystem/</guid>
      <description>1. GFS 是什么？ Google 文件系统（Google File System，缩写为 GFS 或 GoogleFS），一种专有分布式文件系统，由 Google 公司开发，运行于 Linux 平台上。尽管</description>
    </item>
    
    <item>
      <title>跳表-skip list</title>
      <link>https://spongecaptain.cool/post/datastracture/skiplist/</link>
      <pubDate>Tue, 04 Aug 2020 16:11:01 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/datastracture/skiplist/</guid>
      <description>跳表作为一种数据结构，由 William Pugh 在其 1990 年发表的论文 Skip Lists: A Probabilistic Alternative to Balanced Trees 中提出。 1. 逻辑上的跳表 将跳表称为跳跃查询的链表更合适。 无论采用哪一种数据结构，</description>
    </item>
    
    <item>
      <title>MapReduce 论文学习</title>
      <link>https://spongecaptain.cool/post/paper/mapreduce/</link>
      <pubDate>Mon, 27 Jul 2020 22:45:21 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/paper/mapreduce/</guid>
      <description>MapReduce 论文学习 不少人说，最近 20 年互联网技术的发展就是其他公司学习谷歌的过程，MapReduce: Simpliﬁed Data Processing on Large Clusters 论文是 Google 开源后影响深</description>
    </item>
    
    <item>
      <title>AspectJ 动态代理的实际演练</title>
      <link>https://spongecaptain.cool/post/java/aspectjproxy/</link>
      <pubDate>Wed, 22 Jul 2020 21:03:57 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/java/aspectjproxy/</guid>
      <description>AspectJ 动态代理的实际演练 1. AOP 的概念引入 AspectJ 从其命名就可以看出其强调面向切面编程，什么是面向切面编程？ Aspect Oriented Programming（AOP），俗称面向</description>
    </item>
    
    <item>
      <title>CGLIB 动态代理的实际演练</title>
      <link>https://spongecaptain.cool/post/java/cglibproxy/</link>
      <pubDate>Wed, 22 Jul 2020 21:03:45 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/java/cglibproxy/</guid>
      <description>#CGLIB 动态代理的实际演练 JDK 动态代理技术最大的问题就在于其必须要求接口参与，即不是接口的方法无法进行动态代理。CGLIB 动态代理技术解决了这个问题</description>
    </item>
    
    <item>
      <title>Java 的代理模式的实现</title>
      <link>https://spongecaptain.cool/post/java/proxypattern/</link>
      <pubDate>Wed, 22 Jul 2020 20:56:48 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/java/proxypattern/</guid>
      <description>关于 Java 的代理技术，我写了一个开源库，推荐对具体实现有兴趣的同学去看看： https://github.com/Spongecaptain/ProxyPatternInJava 1. 为类的方法添加第三方功能-朴素方式 这里提到的第三方功能类似于软件的</description>
    </item>
    
    <item>
      <title>Java 反射小总结</title>
      <link>https://spongecaptain.cool/post/java/refelectionsummary/</link>
      <pubDate>Fri, 17 Jul 2020 23:24:19 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/java/refelectionsummary/</guid>
      <description>Java 反射小总结 1. Java 反射能做什么？ Java 反射：在运行状态中，能够任意一个类的所有属性和方法，能够调用任意一个对象的的方法和属性； Java &amp;ldquo;正射</description>
    </item>
    
    <item>
      <title>窥探 MySQL 索引</title>
      <link>https://spongecaptain.cool/post/mysql/mysqlindexsummary/</link>
      <pubDate>Fri, 10 Jul 2020 23:11:12 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/mysql/mysqlindexsummary/</guid>
      <description>MySQL 索引 1. 什么是数据库索引 在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。 索引是关系数据库中</description>
    </item>
    
    <item>
      <title>Hugo 博客搭建指北</title>
      <link>https://spongecaptain.cool/post/hugo/howtousehugo/</link>
      <pubDate>Tue, 07 Jul 2020 11:53:47 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/post/hugo/howtousehugo/</guid>
      <description>Hugo 博客搭建指北 自己曾经搭建过基于 Hexo 的博客，由于诸多原因弃之，在此启用 Hugo 作为静态博客。 1. 安装 Hugo 1 2 brew install hugo # 安装 Hugo hugo version # 安装版本查询，成功则说明</description>
    </item>
    
    <item>
      <title></title>
      <link>https://spongecaptain.cool/about/</link>
      <pubDate>Tue, 07 Jul 2020 00:02:06 +0800</pubDate>
      
      <guid>https://spongecaptain.cool/about/</guid>
      <description>About Me _______..______ ______ .__ __. _______ _______ / || _ \ / __ \ | \ | | / _____|| ____| | (----`| |_) | | | | | | \| | | | __ | |__ \ \ | ___/ | | | | | . ` | | | |_ | | __| .----) | | | | `--&#39; | | |\ | | |__| | |</description>
    </item>
    
  </channel>
</rss>
