<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>跳表-skip list - Spongecaptain 的个人技术博客</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Spongecaptain" /><meta name="description" content="跳表作为一种数据结构，由 William Pugh 在其 1990 年发表的论文 Skip Lists: A Probabilistic Alternative to Balanced Trees 中提出。 1. 逻辑上的跳表 将跳表称为跳跃查询的链表更合适。 无论采用哪一种数据结构，" /><meta name="keywords" content="skip list, 跳表" />






<meta name="generator" content="Hugo 0.82.0 with theme even" />


<link rel="canonical" href="https://spongecaptain.cool/post/datastracture/skiplist/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.20eaaf634d4dd8fdd9ee27392a8a8d7542264cd21577a22499a924b5f4a112ef.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="跳表-skip list" />
<meta property="og:description" content="跳表作为一种数据结构，由 William Pugh 在其 1990 年发表的论文 Skip Lists: A Probabilistic Alternative to Balanced Trees 中提出。 1. 逻辑上的跳表 将跳表称为跳跃查询的链表更合适。 无论采用哪一种数据结构，" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://spongecaptain.cool/post/datastracture/skiplist/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-08-04T16:11:01&#43;08:00" />
<meta property="article:modified_time" content="2020-08-04T16:11:01&#43;08:00" />

<meta itemprop="name" content="跳表-skip list">
<meta itemprop="description" content="跳表作为一种数据结构，由 William Pugh 在其 1990 年发表的论文 Skip Lists: A Probabilistic Alternative to Balanced Trees 中提出。 1. 逻辑上的跳表 将跳表称为跳跃查询的链表更合适。 无论采用哪一种数据结构，"><meta itemprop="datePublished" content="2020-08-04T16:11:01&#43;08:00" />
<meta itemprop="dateModified" content="2020-08-04T16:11:01&#43;08:00" />
<meta itemprop="wordCount" content="5359">
<meta itemprop="keywords" content="skip list,跳表," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="跳表-skip list"/>
<meta name="twitter:description" content="跳表作为一种数据结构，由 William Pugh 在其 1990 年发表的论文 Skip Lists: A Probabilistic Alternative to Balanced Trees 中提出。 1. 逻辑上的跳表 将跳表称为跳跃查询的链表更合适。 无论采用哪一种数据结构，"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body class = body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Spongecaptain&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/about/index.html">
        <li class="mobile-menu-item">关于</li>
      </a><a href="https://spongecaptain.cool/SimpleClearFileIO/">
        <li class="mobile-menu-item">文件I/O简明概述</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Spongecaptain&#39;s Blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/index.html">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="https://spongecaptain.cool/SimpleClearFileIO/">文件I/O简明概述</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">跳表-skip list</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-08-04 </span>
        <div class="post-category">
            <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"> 数据结构 </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#1-逻辑上的跳表">1. 逻辑上的跳表</a></li>
    <li><a href="#2-实际的跳表">2. 实际的跳表</a></li>
    <li><a href="#3-跳表与其他数据结构">3. 跳表与其他数据结构</a></li>
    <li><a href="#4-手写一个-skip-list">4. 手写一个 Skip List</a></li>
    <li><a href="#5-引用说明">5. 引用说明</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <blockquote>
<p>跳表作为一种数据结构，由 William Pugh 在其 1990 年发表的论文 <a href="ftp://ftp.cs.umd.edu/pub/skipLists/skiplists.pdf">Skip Lists: A Probabilistic Alternative to Balanced Trees</a> 中提出。</p>
</blockquote>
<h2 id="1-逻辑上的跳表">1. 逻辑上的跳表</h2>
<blockquote>
<p>将跳表称为跳跃查询的链表更合适。</p>
</blockquote>
<p>无论采用哪一种数据结构，如果想要提高查询的效率，势必需要引入顺序性，例如：</p>
<ul>
<li>
<p>有序数组：采用二分法来加快查询速度；</p>
<p><img src="../../../images/img_dataStracture/image-20200804111047980.png" alt="image-20200804111047980" style="zoom:25%;" /></p>
</li>
<li>
<p>B+ 树：采用 B+ 树作为数据结构的索引可以可以依赖于有序快速进行查找；</p>
</li>
</ul>
<p>上述两种方式的查询时间复杂度都是 <code>O(logN)</code> ，但是有着各自的缺点：</p>
<ul>
<li>有序数组的缺点：插入新元素时需要以二分法进行比较，时间复杂度 <code>O(logN)</code>，然后插入时需要将待插入位置以及后续元素整体向后搬移，时间复杂度 <code>O(N)</code>。可见有序数组在插入元素时开销非常大；</li>
<li>B+ 树：B + 树可以说是对红黑树的改进版本，主要缺点在于具体实现比较复杂；</li>
</ul>
<p>跳跃表基于有序链表实现，链表的插入元素和查询的效率如下：</p>
<ul>
<li>
<p>插入时无法使用二分法，因而需要从前向后遍历比较，直到找到应当插入的位置。比较的效率为  <code>O(N)</code>，插入的效率为 <code>O(N)</code>；</p>
<blockquote>
<p>链表解决了数组的单纯插入操作效率较低问题，但是却额外引入了比较无法使用二分法效率低下的问题，其和数组相比效率甚至更差一些。</p>
<p>本质原因：仅仅为了有序性在付出额外性能开销，但是没有从有序性得到任何性能上的好处。</p>
</blockquote>
</li>
<li>
<p>查询时也无法使用二分法，因而需要从前向后遍历比较查询，比较的效率为  <code>O(N)</code>；</p>
</li>
</ul>
<p><img src="../../../images/img_dataStracture/image-20200804111819658.png" alt="image-20200804111819658" style="zoom:25%;" /></p>
<p>可见链表的最大的问题就是不能使用二分法进行查询，无论是查询还是插入元素都需要依次遍历，节点元素之间的有序性根本就没用到。</p>
<p>为此，跳跃表吸收了 B+ 树的思想，也使用索引，只不过跳跃表的索引基于链表实现而非树实现，其实现如下图所示：</p>
<p><img src="../../../images/img_dataStracture/image-20200804112816024.png" alt="image-20200804112816024"></p>
<p>在这里，我们从原有序链表中取出奇数位置的节点作为关键节点链表，在查询或者插入比较时，先通过关键节点链表的比较再去原有序链表中进行比较。例如，如果要插入值为 13 的节点，那么原本需要比较：1、4、9、14 节点，现在只需比较 1、9、14 节点，平均可以节约 1/2 的查询时间。</p>
<p>不过，这里由于节点较少，查询效率的提高并不明显，另一方面，仅仅只有一层关键节点链表仅仅能提高一倍的查询效率，为了解决这个问题，我们可以建立多层关键链表节点，每一层都选取下一层的部分节点作为元素，比如我们建立两层索引的跳表的数据结构如下：</p>
<p><img src="../../../images/img_dataStracture/image-20200804113631837-6528751.png" alt="image-20200804113631837" style="zoom:25%;" /></p>
<p>可见，最终的查询效率为原本的 2^n^ 倍，其中 n 为索引的层数，不过效率的提高有一个极限，意味当最高层索引元素只有 2 个时，已经不够再向上叠加新的索引层了，换言之，最终的查询效率至多可以到 <code>O(logN)</code>。</p>
<p>跳跃表的 skip 含义就是为了强调虽然其基于链表，但是不同于链表单向的<strong>逐个</strong>节点比较，而是可以跳跃若干个节点后进行比较（跳跃即逐个的反义词）。</p>
<hr>
<p>不过，跳跃表和大多数索引数据结构有着一样的问题，在元素删减的时候需要维护索引数据结构，具体来说便是：</p>
<ul>
<li>添加新元素节点时，如果索引不同时进行更新，那么索引就会因为没有覆盖大部分元素而降低查找效率；</li>
<li>删除新元素节点时，如果索引中有对应的节点，如果此时不删除，那么就会引发空指针异常；</li>
</ul>
<p>删除节点时通过高层索引向低层索引层层递进，进行查找，因此时间复杂度在层数最高时为  <code>O(logN)</code>，逻辑也比较简单，相当于查询的过程中顺便将节点元素删除了。</p>
<p>添加节点时逻辑要更复杂一些，因为涉及将哪一个节点选举为高层索引的问题。每一层对于新添加节点的选举逻辑是抛硬币，也就是有 50% 的概率选举为上层链表的节点，被选举的节点需要插入到上层链表的相应位置中。然后，又进行抛硬币，判断是否要选举到上上层链表。因此一个新接入的节点即可能没有加入任何索引中，也有可能加入到所有索引中。这是一个递归的过程，直到某一次选举失败。</p>
<blockquote>
<p>之前的奇偶法选举很难实现，一方面增删元素时会导致元素的奇偶性改变，另一方面，节点没有下标索引，因此很难表示某一个节点奇偶性。</p>
</blockquote>
<p><strong>为什么采用抛硬币的方式？</strong></p>
<ul>
<li>节点选举是比较困难的，因为跳跃表的节点增删操作不可预测，很难用一种有效的算法确保跳表的索引对于最底层的链表来说是均匀的；</li>
<li>如果强行追求上层节点个数恰好为下层节点个数的 2 倍，那么</li>
<li>大数据理论告诉我们，当节点元素足够多时，这种选举策略是趋近于均匀分布的；</li>
</ul>
<p>总结一下跳表的增删元素的操作：</p>
<ul>
<li>增加元素
<ul>
<li>新节点和各层索引节点逐一比较，确定原链表的插入位置。O(logN)</li>
<li>把索引插入到原链表。O(1)</li>
<li>利用抛硬币的随机方式，决定新节点是否提升为上一级索引。结果为 “正” 则提升并继续抛硬币，结果为 “负” 则停止。O(logN)</li>
</ul>
</li>
<li>删除元素
<ul>
<li>自上而下，查找第一次出现节点的索引，并逐层找到每一层对应的节点。O(logN)</li>
<li>删除每一层查找到的节点，如果该层只剩下 1 个节点，删除整个一层（原链表除外）。O(logN)</li>
</ul>
</li>
</ul>
<p>总体上，跳跃表删除操作的时间复杂度是 O(logN)。</p>
<h2 id="2-实际的跳表">2. 实际的跳表</h2>
<p>逻辑上的跳表有一个问题，节点信息存在冗余存储。拿下图为例：</p>
<p><img src="../../../images/img_dataStracture/image-20200804113631837.png" alt="image-20200804113631837" style="zoom:25%;" /></p>
<p>存在冗余的节点有：</p>
<ul>
<li>节点 1、节点 15 一共出现了 3 次；</li>
<li>节点 9 出现了 2 次。</li>
</ul>
<p>为了避免存储信息的冗余，我们对于原有序链表的每一个节点不再要求其仅仅能使用一个向后的指针，而是多个。</p>
<blockquote>
<p>这点类似于从二叉树转变为多路二叉树时节点可以拥有不止 2 个向后的节点引用指针。</p>
</blockquote>
<p>我们先来看一个有序链表，如下图（最左侧的灰色节点表示一个空的头结点）：</p>
<blockquote>
<p>下面的若干张图引来自<a href="https://www.zhihu.com/people/zhtielei">张铁蕾</a>。</p>
</blockquote>
<p><img src="../../../images/img_dataStracture/image-20200804150110591.png" alt="image-20200804150110591"></p>
<p>假如我们每相邻两个节点增加一个指针，让指针指向下下个节点，如下图：</p>
<p><img src="../../../images/img_dataStracture/image-20200804150131812.png" alt="image-20200804150131812"></p>
<blockquote>
<p>这样一来在逻辑上相当于构造了两个单向链表，通过在每一个节点中使用额外的指针避免重复使用节点。</p>
</blockquote>
<p>利用同样的方式，我们可以在上层新产生的链表上，继续为每相邻的两个节点增加一个指针，从而产生第三层链表。如下图：</p>
<p><img src="../../../images/img_dataStracture/image-20200804150153773.png" alt="image-20200804150153773"></p>
<p>不过需要注意的是，每增加一层还是要为每一层单独增加该层的头节点，头节点是跳表每一层的起始节点。</p>
<blockquote>
<p>你可以观察到第一个灰色块从一开始的单个节点元素逐渐增加到 3 个节点元素。</p>
</blockquote>
<hr>
<h2 id="3-跳表与其他数据结构">3. 跳表与其他数据结构</h2>
<p><strong>跳跃表和平衡二叉搜索树的区别</strong>：</p>
<ul>
<li>数据结构不同：跳跃表基于链表，平衡二叉搜索树基于树；</li>
<li>索引的维护效率：跳跃表依靠抛硬币的随机方式维护索引（要求尽量平衡或平均），成本比较低，而平衡二叉搜索树需要基于特定的 reblance 算法重新调整树状结构。</li>
<li>平衡性：跳跃表的平衡性依据随机性来包装，因此最终的查找效率至多趋近于 <code>O(logN)</code>，但是平衡二叉树通过 rebalance 算法，能够达到 <code>O(logN)</code> 的查找效率；</li>
<li>范围查找的复杂性：在做范围查找的时候，平衡树比 skiplist 操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在 skiplist 上进行范围查找就非常简单，只需要在找到小值之后，对第 1 层链表进行若干步的遍历就可以实现。</li>
<li>内存占用角度：从内存占用上来说，skiplist 比平衡树更灵活一些。一般来说，平衡树每个节点包含 2 个指针（分别指向左右子树），而 skiplist 每个节点包含的指针数目平均为 1/(1-p)，具体取决于参数 p 的大小。如果像 Redis 里的实现一样，取 p=1/4，那么平均每个节点包含 1.33 个指针，比平衡树更有优势。</li>
<li>算法难度：从算法实现难度上来比较，skiplist 比平衡树要简单得多了；</li>
</ul>
<p><strong>Hash 表的独有特点</strong>：skiplist 和各种平衡树（如 AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个 key 的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。</p>
<p><strong>查询效率的比较</strong>：查找单个 key，skiplist 和平衡树的时间复杂度都为 <code>O(logN)</code>，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近 O (1)，性能更高一些。所以我们平常使用的各种 Map 或 dictionary 结构，大都是基于哈希表实现的。</p>
<h2 id="4-手写一个-skip-list">4. 手写一个 Skip List</h2>
<p>首先是节点类，这里 Skip List 模型中的节点有着上下左右，共四个节点的引用指针，当然在很多应用中并不需要这么多指针。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;{</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="n">key</span><span class="o">;</span>
  <span class="kd">public</span> <span class="n">T</span> <span class="n">value</span><span class="o">;</span>
  <span class="kd">public</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">up</span><span class="o">,</span> <span class="n">down</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">;</span><span class="c1">// 上下左右 四个指针
</span><span class="c1"></span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">HEAD_KEY</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span> <span class="c1">// 负无穷
</span><span class="c1"></span>  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span>  <span class="n">TAIL_KEY</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span> <span class="c1">// 正无穷
</span><span class="c1"></span>
  <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="n">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="c1">//key 与 value 的 get/set 方法
</span><span class="c1"></span>  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getKey</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">key</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setKey</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="kd">public</span> <span class="n">T</span> <span class="nf">getValue</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setValue</span><span class="o">(</span><span class="n">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="c1">//节点相同的逻辑是 key 与 value 都应当相同，或者直接引用地址相同
</span><span class="c1"></span>  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>

    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">==</span><span class="n">o</span><span class="o">)</span> <span class="o">{</span><span class="c1">//引用相同
</span><span class="c1"></span>      <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">o</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(!(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="n">Node</span><span class="o">&lt;?&gt;))</span> <span class="o">{</span><span class="c1">//类型一定要为 Node
</span><span class="c1"></span>      <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">ent</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="n">ent</span> <span class="o">=</span> <span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;)</span>  <span class="n">o</span><span class="o">;</span> <span class="c1">// 检测类型
</span><span class="c1"></span>    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ClassCastException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">ent</span><span class="o">.</span><span class="na">getKey</span><span class="o">()</span> <span class="o">==</span> <span class="n">key</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">ent</span><span class="o">.</span><span class="na">getValue</span><span class="o">()</span> <span class="o">==</span> <span class="n">value</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="c1">//toString
</span><span class="c1"></span>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="s">&#34;key-value:&#34;</span><span class="o">+</span><span class="n">key</span><span class="o">+</span><span class="s">&#34;-&#34;</span><span class="o">+</span><span class="n">value</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在之前的章节有提到逻辑上的跳表结构存在节点数据冗余的问题，一种解决办法已经提到了，每一个节点可以使用多个向后的指针。不过这里采用另一种方式，顶层节点的 value 设置为 null，仅仅保存 key 值，这样一来在保持简单逻辑的情况下，能够减少节点数据冗余。</p>
<blockquote>
<p>这种思路类似于 B+ 树中只有 leaf page 存储行数据，其他节点仅仅存储指向下一层节点的指针以及索引。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SkipList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="c1">//在每次插入元素后，即使有新的顶层生成，head、tail 还是指向最顶层的 head、tail，此顶层的 head、tail 可以通过 down 指针得到
</span><span class="c1"></span>  <span class="kd">private</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">head</span><span class="o">,</span> <span class="n">tail</span><span class="o">;</span><span class="c1">//head 与 tail
</span><span class="c1"></span>  <span class="kd">private</span> <span class="kt">int</span> <span class="n">nodeNumber</span><span class="o">;</span><span class="c1">//节点总数
</span><span class="c1"></span>  <span class="kd">private</span> <span class="kt">int</span> <span class="n">listLevel</span><span class="o">;</span><span class="c1">//层数
</span><span class="c1"></span>  <span class="kd">private</span> <span class="n">Random</span> <span class="n">random</span><span class="o">;</span><span class="c1">// 用于投掷硬币
</span><span class="c1"></span>  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">double</span> <span class="n">PROBABILITY</span> <span class="o">=</span> <span class="n">0</span><span class="o">.</span><span class="na">5</span><span class="o">;</span><span class="c1">//对新插入元素向上选举的概率设定为 0.5
</span><span class="c1"></span>
  <span class="kd">public</span> <span class="nf">SkipList</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// TODO Auto-generated constructor stub
</span><span class="c1"></span>    <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Random</span><span class="o">();</span>
    <span class="n">clear</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="cm">/**
</span><span class="cm">     *清空跳跃表
</span><span class="cm">     * */</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">clear</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;(</span><span class="n">Node</span><span class="o">.</span><span class="na">HEAD_KEY</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="n">tail</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;(</span><span class="n">Node</span><span class="o">.</span><span class="na">TAIL_KEY</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="n">horizontalLink</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">tail</span><span class="o">);</span>
    <span class="n">listLevel</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
    <span class="n">nodeNumber</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isEmpty</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">nodeNumber</span> <span class="o">==</span> <span class="n">0</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">nodeNumber</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="cm">/**
</span><span class="cm">     * 在最下面一层，找到要插入的位置前面的那个 key
</span><span class="cm">     * */</span>
  <span class="kd">private</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">findNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">while</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">key</span> <span class="o">!=</span> <span class="n">Node</span><span class="o">.</span><span class="na">TAIL_KEY</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">key</span> <span class="o">&lt;=</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span><span class="c1">//先遍历顶层元素
</span><span class="c1"></span>        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">down</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span><span class="c1">//通过 p.down 得到下一层
</span><span class="c1"></span>        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">down</span><span class="o">;</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span><span class="c1">//p.down 说明已经遍历到最后一层，此时直接选择节点插入到当前节点后即可（注意此时 p 一定不符合 while 条件）
</span><span class="c1"></span>        <span class="k">break</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="cm">/**
</span><span class="cm">     * 查找是否存储key，存在则返回该节点，否则返回null
</span><span class="cm">     * */</span>
  <span class="kd">public</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">search</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">findNode</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="n">p</span><span class="o">.</span><span class="na">getKey</span><span class="o">())</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">p</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="cm">/**
</span><span class="cm">     * 向跳跃表中添加key-value，这是最跳表实现最复杂的地方
</span><span class="cm">     * */</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="n">T</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//在最下面一层，找到要插入的位置前面的那个 key
</span><span class="c1"></span>    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">findNode</span><span class="o">(</span><span class="n">k</span><span class="o">);</span>
    <span class="c1">//如果key值相同，替换原来的 value 即可结束
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">p</span><span class="o">.</span><span class="na">getKey</span><span class="o">())</span> <span class="o">{</span>
      <span class="n">p</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
      <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">//如果 key 不相同，那么在最底层插入该节点，此时仅仅需要调用 backLink() 进行插入即可
</span><span class="c1"></span>    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
    <span class="n">backLink</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">q</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">currentLevel</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span><span class="c1">//当前所在的层级是0
</span><span class="c1"></span>    <span class="c1">//抛硬币
</span><span class="c1"></span>    <span class="k">while</span> <span class="o">(</span><span class="n">random</span><span class="o">.</span><span class="na">nextDouble</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="n">PROBABILITY</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">//如果超出了高度，需要重新建一个顶层，注意新的顶层与原顶层之间需要通过指针联系
</span><span class="c1"></span>      <span class="k">if</span> <span class="o">(</span><span class="n">currentLevel</span> <span class="o">&gt;=</span> <span class="n">listLevel</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//新建顶层的初始化
</span><span class="c1"></span>        <span class="n">listLevel</span><span class="o">++;</span>
        <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;(</span><span class="n">Node</span><span class="o">.</span><span class="na">HEAD_KEY</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;(</span><span class="n">Node</span><span class="o">.</span><span class="na">TAIL_KEY</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="n">horizontalLink</span><span class="o">(</span><span class="n">p1</span><span class="o">,</span> <span class="n">p2</span><span class="o">);</span>
        <span class="c1">//新键顶层和底层元素建立指针联系
</span><span class="c1"></span>        <span class="n">vertiacallLink</span><span class="o">(</span><span class="n">p1</span><span class="o">,</span> <span class="n">head</span><span class="o">);</span>
        <span class="n">vertiacallLink</span><span class="o">(</span><span class="n">p2</span><span class="o">,</span> <span class="n">tail</span><span class="o">);</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">p1</span><span class="o">;</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="n">p2</span><span class="o">;</span>
        <span class="c1">//新的顶层构建完毕后，顶层只有新的 head 与 tail 节点
</span><span class="c1"></span>      <span class="o">}</span>
      <span class="c1">//总之，通过上面的逻辑确保了下面的逻辑中层数一定是够用的
</span><span class="c1"></span>      <span class="c1">//寻找当前层 p 后面且 p.up != null 的 p 元素，如果存在这个元素，说明 q 节点被选举为上层节点后，应当置于 p.up 后
</span><span class="c1"></span>      <span class="k">while</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">up</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">up</span><span class="o">;</span>
      <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;(</span><span class="n">k</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span><span class="c1">//为了减少数据冗余，这里只保存 key，Value 设置为 null 的 e,key 与原 p 相同
</span><span class="c1"></span>      <span class="n">backLink</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span><span class="c1">//将e插入到p的后面
</span><span class="c1"></span>      <span class="n">vertiacallLink</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">q</span><span class="o">);</span><span class="c1">//将e和q上下连接
</span><span class="c1"></span>      <span class="n">q</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
      <span class="n">currentLevel</span><span class="o">++;</span><span class="c1">//层级数递增
</span><span class="c1"></span>    <span class="o">}</span>
    <span class="n">nodeNumber</span><span class="o">++;</span><span class="c1">//节点数递增
</span><span class="c1"></span>  <span class="o">}</span>

  <span class="c1">//node1后面插入node2
</span><span class="c1"></span>  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">backLink</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">node1</span><span class="o">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">node2</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">node2</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">node1</span><span class="o">;</span>
    <span class="n">node2</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">node1</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
    <span class="n">node1</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">node2</span><span class="o">;</span>
    <span class="n">node1</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">node2</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="cm">/**
</span><span class="cm">     * 水平双向连接
</span><span class="cm">     * */</span>
  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">horizontalLink</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">node1</span><span class="o">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">node2</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">node1</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">node2</span><span class="o">;</span>
    <span class="n">node2</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">node1</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="cm">/**
</span><span class="cm">     * 垂直双向连接
</span><span class="cm">     * */</span>
  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">vertiacallLink</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">node1</span><span class="o">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">node2</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">node1</span><span class="o">.</span><span class="na">down</span> <span class="o">=</span> <span class="n">node2</span><span class="o">;</span>
    <span class="n">node2</span><span class="o">.</span><span class="na">up</span> <span class="o">=</span> <span class="n">node1</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="cm">/**
</span><span class="cm">     * 按照 key 的升序依次打印出原始数据
</span><span class="cm">     * */</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">isEmpty</span><span class="o">())</span> <span class="o">{</span>
      <span class="k">return</span> <span class="s">&#34;跳跃表为空！&#34;</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">StringBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">down</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">down</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">builder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
      <span class="n">builder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">&#34;\n&#34;</span><span class="o">);</span>
      <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">builder</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="cm">/**
</span><span class="cm">     * 按照层序依次从左到右打印出所有的节点，这可以详细地表示出具体的数据结构
</span><span class="cm">     */</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">layerTraverse</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">headOnCurrentLayer</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">currentNode</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">headOnCurrentLayer</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">i</span><span class="o">++;</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;第 &#34;</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">&#34; 层&#34;</span><span class="o">);</span>
      <span class="k">while</span> <span class="o">(</span><span class="n">currentNode</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">currentNode</span><span class="o">);</span>
        <span class="n">currentNode</span> <span class="o">=</span> <span class="n">currentNode</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="n">headOnCurrentLayer</span> <span class="o">=</span> <span class="n">headOnCurrentLayer</span><span class="o">.</span><span class="na">down</span><span class="o">;</span>
      <span class="n">currentNode</span> <span class="o">=</span> <span class="n">headOnCurrentLayer</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>测试代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">SkipList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SkipList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
    <span class="c1">//添加入新元素
</span><span class="c1"></span>    <span class="n">list</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">2</span><span class="o">,</span> <span class="s">&#34;spongecaptainR_2&#34;</span><span class="o">);</span>
    <span class="n">list</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">1</span><span class="o">,</span> <span class="s">&#34;spongecaptain_1&#34;</span><span class="o">);</span>
    <span class="n">list</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">3</span><span class="o">,</span> <span class="s">&#34;spongecaptain_3&#34;</span><span class="o">);</span>
    <span class="n">list</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">1</span><span class="o">,</span> <span class="s">&#34;spongecaptain_1_1&#34;</span><span class="o">);</span><span class="c1">//测试同一个key值
</span><span class="c1"></span>    <span class="n">list</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">4</span><span class="o">,</span> <span class="s">&#34;spongecaptain_4&#34;</span><span class="o">);</span>
    <span class="n">list</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">6</span><span class="o">,</span> <span class="s">&#34;spongecaptain_6&#34;</span><span class="o">);</span>
    <span class="n">list</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">5</span><span class="o">,</span> <span class="s">&#34;spongecaptain_5&#34;</span><span class="o">);</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">list</span><span class="o">);</span><span class="c1">//跳跃表按照 key 顺序进行打印
</span><span class="c1"></span>    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;------------------------------&#34;</span><span class="o">);</span>
    <span class="n">list</span><span class="o">.</span><span class="na">layerTraverse</span><span class="o">();</span><span class="c1">//跳跃表按照层级结构遍历，每一层的遍历都是从左到右的遍历
</span><span class="c1"></span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>控制台打印出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">key-value:1-spongecaptain_1_1
key-value:2-spongecaptainR_2
key-value:3-spongecaptain_3
key-value:4-spongecaptain_4
key-value:5-spongecaptain_5
key-value:6-spongecaptain_6

------------------------------
第 1 层
key-value:-2147483648-null
key-value:2-null
key-value:2147483647-null
第 2 层
key-value:-2147483648-null
key-value:2-null
key-value:4-null
key-value:6-null
key-value:2147483647-null
第 3 层
key-value:-2147483648-null
key-value:1-null
key-value:2-null
key-value:4-null
key-value:6-null
key-value:2147483647-null
第 4 层
key-value:-2147483648-null
key-value:1-spongecaptain_1_1
key-value:2-spongecaptainR_2
key-value:3-spongecaptain_3
key-value:4-spongecaptain_4
key-value:5-spongecaptain_5
key-value:6-spongecaptain_6
key-value:2147483647-null
</code></pre></td></tr></table>
</div>
</div><p>注意：由于随机性，跳表的层数可以是 1- 4 层，每次执行的结果可能都不相同，但是特征是不变的：</p>
<ul>
<li>每一层都有相同 key 的 head、tail 节点，但是注意它们是不同的节点，即引用地址不同；</li>
<li>每一层的所有节点都是按照 key 从小到大升序排序的；</li>
<li>除了最后一层链表的节点的 value 不为 null，其余所有节点的 value 均为 null；</li>
<li>随机性并不会影响最后一层链表有哪些节点以及节点的顺序；</li>
</ul>
<h2 id="5-引用说明">5. 引用说明</h2>
<p>部分引用：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/23370124">https://zhuanlan.zhihu.com/p/23370124</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/53975333">https://zhuanlan.zhihu.com/p/53975333</a></li>
<li><a href="https://blog.csdn.net/brillianteagle/article/details/52206261">https://blog.csdn.net/brillianteagle/article/details/52206261</a></li>
</ul>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/skip-list/">skip list</a>
          <a href="/tags/%E8%B7%B3%E8%A1%A8/">跳表</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/paper/googlefilesystem/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Google File System-GFS 论文阅读</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/paper/mapreduce/">
            <span class="next-text nav-default">MapReduce 论文学习</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>


      <h3>转载申请</h3>
      <a rel=license href=https://creativecommons.org/licenses/by/4.0>
        <img alt=知识共享许可协议 style=border-width:0 src=../../static/creative-commons.png>
      </a>
      <br>本作品采用
      <a rel=license href=http://creativecommons.org/licenses/by/4.0/ target="_blank" style="text-decoration:underline;" >
      知识共享署名 4.0 国际许可协议</a>
      进行许可，转载时请注明作者姓名以及原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。

      
    </footer>
  </article>
        </div>
        <div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js" crossorigin="anonymous"></script>
    <script type="text/javascript">
      var gitalk = new Gitalk({
        id: '2020-08-04 16:11:01 \u002b0800 CST',
        title: '跳表-skip list',
        clientID: 'b8e9909664fb69930809',
        clientSecret: '847d9069c9532ab260721afb9f036cdb8f52aec4',
        repo: 'Spongecaptain.github.io',
        owner: 'Spongecaptain',
        admin: ['Spongecaptain'],
        body: decodeURI(location.href)
      });
      gitalk.render('gitalk-container');
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/gitalk/gitalk">comments powered by gitalk.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:wjjiang19@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/spongecaptain" class="iconfont icon-github" title="github"></a>
  <a href="https://spongecaptain.cool/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2019 - 
    2022
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Spongecaptain</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.2517c0eb67172a0bae917de4af59b10ca2531411a009d4c0b82f5685259e5771.js"></script>








</body>
</html>
