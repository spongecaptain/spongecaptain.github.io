<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Java 的代理模式的实现 - Spongecaptain 的个人技术博客</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Spongecaptain" /><meta name="description" content="关于 Java 的代理技术，我写了一个开源库，推荐对具体实现有兴趣的同学去看看： https://github.com/Spongecaptain/ProxyPatternInJava 1. 为类的方法添加第三方功能-朴素方式 这里提到的第三方功能类似于软件的" /><meta name="keywords" content="Java, 代理模式" />






<meta name="generator" content="Hugo 0.82.0 with theme even" />


<link rel="canonical" href="https://spongecaptain.cool/post/java/proxypattern/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.20eaaf634d4dd8fdd9ee27392a8a8d7542264cd21577a22499a924b5f4a112ef.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Java 的代理模式的实现" />
<meta property="og:description" content="关于 Java 的代理技术，我写了一个开源库，推荐对具体实现有兴趣的同学去看看： https://github.com/Spongecaptain/ProxyPatternInJava 1. 为类的方法添加第三方功能-朴素方式 这里提到的第三方功能类似于软件的" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://spongecaptain.cool/post/java/proxypattern/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-07-22T20:56:48&#43;08:00" />
<meta property="article:modified_time" content="2020-07-22T20:56:48&#43;08:00" />

<meta itemprop="name" content="Java 的代理模式的实现">
<meta itemprop="description" content="关于 Java 的代理技术，我写了一个开源库，推荐对具体实现有兴趣的同学去看看： https://github.com/Spongecaptain/ProxyPatternInJava 1. 为类的方法添加第三方功能-朴素方式 这里提到的第三方功能类似于软件的"><meta itemprop="datePublished" content="2020-07-22T20:56:48&#43;08:00" />
<meta itemprop="dateModified" content="2020-07-22T20:56:48&#43;08:00" />
<meta itemprop="wordCount" content="5191">
<meta itemprop="keywords" content="Java,代理模式,动态代理," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java 的代理模式的实现"/>
<meta name="twitter:description" content="关于 Java 的代理技术，我写了一个开源库，推荐对具体实现有兴趣的同学去看看： https://github.com/Spongecaptain/ProxyPatternInJava 1. 为类的方法添加第三方功能-朴素方式 这里提到的第三方功能类似于软件的"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body class = body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Spongecaptain&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/about/index.html">
        <li class="mobile-menu-item">关于</li>
      </a><a href="https://spongecaptain.cool/SimpleClearFileIO/">
        <li class="mobile-menu-item">文件I/O简明概述</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Spongecaptain&#39;s Blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/index.html">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="https://spongecaptain.cool/SimpleClearFileIO/">文件I/O简明概述</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Java 的代理模式的实现</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-07-22 </span>
        <div class="post-category">
            <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"> 设计模式 </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#1-为类的方法添加第三方功能-朴素方式">1. 为类的方法添加第三方功能-朴素方式</a></li>
    <li><a href="#2-为类添加第三方功能-奇思妙想">2. 为类添加第三方功能-奇思妙想</a>
      <ul>
        <li><a href="#21-jdk-动态代理">2.1 JDK 动态代理</a></li>
        <li><a href="#22-cglib-动态代理">2.2 CGLIB 动态代理</a></li>
        <li><a href="#23-aspectj-动态代理">2.3 AspectJ 动态代理</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>关于 Java 的代理技术，我写了一个开源库，推荐对具体实现有兴趣的同学去看看：</p>
<p><a href="https://github.com/Spongecaptain/ProxyPatternInJava">https://github.com/Spongecaptain/ProxyPatternInJava</a></p>
<h2 id="1-为类的方法添加第三方功能-朴素方式">1. 为类的方法添加第三方功能-朴素方式</h2>
<p>这里提到的第三方功能类似于软件的插件，主要用于添加第三方功能，比如：日志、拦截。</p>
<p><strong>那么我们该如何为类的方法添加第三方功能呢？</strong></p>
<ul>
<li>
<p>首先，我们可以<strong>修改原来的类</strong>，在原来类的方法上直接嵌入第三方功能方法的调用；</p>
<blockquote>
<p>主要缺陷：修改原来的类是非常危险的事情，因为此类可能已经被其他类依赖，一旦修改可能出现各种错误。另一方面，第三方功能的侵入性太强了。</p>
</blockquote>
</li>
<li>
<p>其次，我们可以<strong>为原来的类添加新方法</strong>，在新方法中调用原方法以及第三方功能方法。</p>
<blockquote>
<p>优点：这样原本依赖的此类的类并不会调用新写的方法，因此不会出现依赖错误。</p>
<p>主要缺陷：很多第三方架包我们并不能直接拿到源码，或者并不想编译，总之，一旦没有源码我们就难以为类写新方法；</p>
</blockquote>
</li>
<li>
<p>或者，我们可以<strong>继承</strong>原来的类，重写其被代理方法，重写方法中既调用父类的被代理方法又调用第三方功能的方法。</p>
<blockquote>
<p>优点：不再需要第三方类库的源代码；</p>
<p>主要缺陷：仅仅为了代理方法就设计一个子类，面向对象的继承关系混乱。</p>
</blockquote>
</li>
<li>
<p>最后，我们可以采用<strong>静态代理</strong>的手段，只要原来的类需要被代理的方法来自接口，那么我们通过实现此接口，并在接口方法中调用第三方代码以及原来的方法就能实现代理。</p>
<blockquote>
<p>优点：不再需要第三方类库的源代码；</p>
<p>主要缺陷：每次想添加一个新的代理功能，那么必须要实现一个新代理类，代理类会随着被代理的方法而增多。</p>
<p>次要缺陷：对于不是实现于接口的方法无法进行代理。</p>
</blockquote>
</li>
</ul>
<p><strong>注意事项</strong>：下面的方式拥有的缺陷对于上面的方式来说，可能也具备，比如继承和静态代理都有随着新第三方功能的加入需要成正比地添加类数量。</p>
<hr>
<p>下面是上述逻辑的代码案例。</p>
<ul>
<li>
<p>接口：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">interface</span> <span class="nc">Foo</span><span class="o">{</span>
  <span class="kt">void</span> <span class="nf">bar</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>被代理类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Proxyee</span> <span class="kd">implements</span> <span class="n">Foo</span><span class="o">{</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">bar</span><span class="o">(){</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;foo&#34;</span><span class="o">);</span> 
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>第三方功能描述在 <code>bar()</code> 方法的工作的前后分别记录日志，通过调用如下静态方法实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Log</span><span class="o">.</span><span class="na">log</span><span class="o">();</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<p><strong>方式一，直接改写原类的方法</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Proxyee</span> <span class="kd">implements</span> <span class="n">Foo</span><span class="o">{</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">bar</span><span class="o">(){</span>
    <span class="n">Log</span><span class="o">.</span><span class="na">log</span><span class="o">();</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;foo&#34;</span><span class="o">);</span> 
    <span class="n">Log</span><span class="o">.</span><span class="na">log</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>方式二，写一个新方法</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Proxyee</span> <span class="kd">implements</span> <span class="n">Foo</span><span class="o">{</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">bar</span><span class="o">(){</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;foo&#34;</span><span class="o">);</span> 
  <span class="o">}</span>
  <span class="c1">//下面是新方法，和 bar() 方法的区别仅仅在于额外添加了日志系统
</span><span class="c1"></span>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">barProxy</span><span class="o">(){</span>
    <span class="n">Log</span><span class="o">.</span><span class="na">log</span><span class="o">();</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;foo&#34;</span><span class="o">);</span> 
    <span class="n">Log</span><span class="o">.</span><span class="na">log</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>方式三，继承</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Proxyer</span> <span class="kd">extends</span> <span class="n">Proxyee</span><span class="o">{</span>
  <span class="c1">//重写父类方法，区别仅仅在于额外调用了第三方功能：日志系统
</span><span class="c1"></span>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">bar</span><span class="o">(){</span>
    <span class="n">Log</span><span class="o">.</span><span class="na">log</span><span class="o">();</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">bar</span><span class="o">();</span>
    <span class="n">Log</span><span class="o">.</span><span class="na">log</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>方式四，静态代理</strong>：</p>
<blockquote>
<p>代码最长，不过也算是这四个臭皮匠中最好的一个。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//和代理类实现一样的接口（实现哪个接口取决于要代理哪一个类）
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">Proxyer</span> <span class="kd">implements</span> <span class="n">Foo</span><span class="o">{</span>
  <span class="n">Proxyee</span> <span class="n">proxyee</span><span class="o">;</span>
  <span class="kd">public</span> <span class="nf">Proxyer</span><span class="o">(</span><span class="n">Proxyee</span> <span class="n">proxyee</span><span class="o">){</span>
    <span class="k">this</span><span class="o">.</span><span class="na">proxyee</span> <span class="o">=</span> <span class="n">proxyee</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="c1">//实现接口的方法，借此代理
</span><span class="c1"></span>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">bar</span><span class="o">(){</span>
    <span class="n">Log</span><span class="o">.</span><span class="na">log</span><span class="o">();</span>
    <span class="n">proxyee</span><span class="o">.</span><span class="na">bar</span><span class="o">();</span>
    <span class="n">Log</span><span class="o">.</span><span class="na">log</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="2-为类添加第三方功能-奇思妙想">2. 为类添加第三方功能-奇思妙想</h2>
<h3 id="21-jdk-动态代理">2.1 JDK 动态代理</h3>
<p>JDK 动态代理是静态代理的升级版，其还是需要被代理方法一定源于接口的，但是避免了静态代理可能会产生过多代理类的问题。</p>
<p>理解 JDK 动态代理最好的方式就是举一个使用 JDK 动态代理的案例。不过对 Foo 接口进行了简单的修改，为了避免只用无参方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//被代理方法所在接口
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Foo</span> <span class="o">{</span>
    <span class="n">String</span> <span class="nf">bar</span><span class="o">(</span><span class="n">String</span> <span class="n">str</span><span class="o">,</span><span class="kt">int</span> <span class="n">i</span><span class="o">);</span>
<span class="o">}</span>
<span class="c1">//被代理类
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Proxyee</span> <span class="kd">implements</span> <span class="n">Foo</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">bar</span><span class="o">(</span><span class="n">String</span> <span class="n">str</span><span class="o">,</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">+</span><span class="n">i</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">str</span><span class="o">+</span><span class="n">i</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>利用 JDK 的动态代理机制我们需使用 2 个类：</p>
<ul>
<li>java.lang.reflect.Proxy</li>
<li>java.lang.reflect.InvocationHandler</li>
</ul>
<blockquote>
<p>以及其他反射类库中的类。</p>
</blockquote>
<p>这里我们先看如何使用它们，后面会附上原代码。</p>
<p><img src="../../../images/img_java/image-20200716231313268.png" alt="image-20200716231313268" style="zoom: 33%;" /></p>
<p>InvocationHandler 类只有一个方法 <code>invoke()</code> 方法，如上所示，其入口参数有：</p>
<ul>
<li>
<p><code>Object proxy</code>：指向最终执行代理方法的实例；</p>
<blockquote>
<p>为什么是 Object？这是因为代理类一次可以代理多个接口的方法，这里并不能事先确定具体代理哪几个接口的方法。</p>
</blockquote>
</li>
<li>
<p><code>Method method</code>：指向需要被代理的方法。</p>
<blockquote>
<p>给 Proxy.newProxyInstance() 方法传递的接口数组代表 JDK 代理机制负责帮助实现这些接口相关方法的代理，如果不想被代理，可以选择将 interfaces 数据中移除该接口对应的 Class 实例。</p>
<p>Method 方法代表 interfaces 中每一个接口的每一个方法，因此这个 Method 在 Proxy.newProxyInstance() 方法返回值被声明为不同多态的条件下指向不同的方法，这里指的是 <code>Proxyee.bar()</code> 方法。</p>
</blockquote>
</li>
<li>
<p><code>Object[] args</code>：被代理方法的入口参数列表；</p>
</li>
<li>
<p><code>invoke()</code> 方法返回值：此方法的返回值实际上也就是代理类实例(这里就是 proxyer 实例)的任何方法的返回值。如果我们需要链式调用，那么可以使 <code>invoke()</code> 方法返回入口参数 Proxy 类型实例；</p>
</li>
</ul>
<hr>
<p>下面是 JDK 代理机制测试的完整代码，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">java.lang.reflect.InvocationHandler</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Method</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Proxy</span><span class="o">;</span>

<span class="cm">/**
</span><span class="cm"> * @author SpongeCaptain
</span><span class="cm"> * @date 2020/7/16 22:08
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Proxyer</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
  
    <span class="kd">final</span> <span class="n">Proxyee</span> <span class="n">proxyee</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Proxyee</span><span class="o">();</span>
    
    <span class="kd">final</span> <span class="n">ClassLoader</span> <span class="n">classLoader</span> <span class="o">=</span> <span class="n">Proxyee</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">();</span>
    
    <span class="kd">final</span> <span class="n">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">interfaces</span> <span class="o">=</span> <span class="n">Proxyee</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getInterfaces</span><span class="o">();</span>
    
    <span class="n">InvocationHandler</span> <span class="n">myInvocationHandler</span> <span class="o">=</span> <span class="k">new</span> <span class="n">InvocationHandler</span><span class="o">()</span> <span class="o">{</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="n">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="n">Method</span> <span class="n">method</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;--------Log.log()---------&#34;</span><span class="o">);</span>
        <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">proxyee</span><span class="o">,</span> <span class="n">args</span><span class="o">[</span><span class="n">0</span><span class="o">],</span> <span class="n">args</span><span class="o">[</span><span class="n">1</span><span class="o">]);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;--------Log.log()---------&#34;</span><span class="o">);</span>
        <span class="k">return</span> <span class="s">&#34;From Proxyer&#34;</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">};</span>
    
    <span class="n">Foo</span> <span class="n">proxyer</span> <span class="o">=</span> <span class="o">(</span><span class="n">Foo</span><span class="o">)</span> <span class="n">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span>
      <span class="n">classLoader</span><span class="o">,</span> <span class="n">interfaces</span><span class="o">,</span> <span class="n">myInvocationHandler</span><span class="o">);</span>
    
    <span class="n">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">proxyer</span><span class="o">.</span><span class="na">bar</span><span class="o">(</span><span class="s">&#34;hello&#34;</span><span class="o">,</span> <span class="n">2020</span><span class="o">);</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>控制台输出：</p>
<blockquote>
<p>&mdash;&mdash;&ndash;Log.log()&mdash;&mdash;&mdash;
hello2020
&mdash;&mdash;&ndash;Log.log()&mdash;&mdash;&mdash;
From Proxyer</p>
</blockquote>
<hr>
<p><strong>那么 JDK 动态代理的原理是什么？</strong></p>
<p>我们从 <code>Proxy.newProxyInstance(classLoader, interfaces, myInvocationHandler);</code> 方法调用出发，这个方法入口参数依次为：</p>
<ul>
<li>
<p>ClassLoader 实例：用于动态代理类实例的加载；</p>
</li>
<li>
<p>Class&lt;?&gt;[] interfaces 实例：被代理类的所有接口；</p>
<blockquote>
<p>正是因为 JDK 动态代理 API 需要接收接口，因此如果被代理类的某个方法不属于某一个接口，那么该方法就无法被 JDK 动态代理机制处理。</p>
<p><strong>另一方面，如果不希望被代理类的某个接口方法被代理，可以选择将此接口不作为 interfaces 的一员</strong>。</p>
</blockquote>
</li>
<li>
<p>InvocationHandler 实例：通常在 Java 中命令为 Handler 的类是被作为回调函数的封装而存在，而这里就是封装了动态代理方法，回调时机是代理类的代理方法被调用。</p>
</li>
</ul>
<p>首先所有代理类，也就是 <code>Proxy.newProxyInstance(classLoader, interfaces, myInvocationHandler);</code> 方法返回的实例都是 <code>java.lang.reflect.Proxy</code> 类的匿名内部类（也就是继承关系），比如会表示成 <code>com.sun.proxy.$Proxy0</code>。</p>
<blockquote>
<p>当然我使用的是 Sun 的虚拟机，如果是其他虚拟机，那么此类的完全限定名会有所区别。</p>
</blockquote>
<p>其次，代理类又实现了所有被代理类的接口。这句话有点绕口，具体来说就是如果被代理类实现了 A、B、C 三个接口，且将这三个接口实例注入到方法的 interfaces 实例中，那么 <code>Proxy.newProxyInstance(classLoader, interfaces, myInvocationHandler);</code> 方法返回的实例会将上述三个接口都实现。</p>
<p>对于这个说法，可以通过如下的语句来证实：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//superclass 为 java.lang.reflect.Proxy
</span><span class="c1"></span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">proxyer</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getSuperclass</span><span class="o">());</span>
<span class="c1">//interfaces 为 Proxyee 所实现的所有接口
</span><span class="c1"></span><span class="n">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">interfaces1</span> <span class="o">=</span> <span class="n">proxyer</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getInterfaces</span><span class="o">();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">interfaces1</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">interfaces1</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">getName</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>那么 JDK 动态代理具体来说是如何实现的呢？</strong></p>
<p>先说结论：</p>
<ul>
<li>步骤 1：利用我们在刚才输入的类加载器实例、interfaces、InvocationHandler 实例进行动态生成 com.sun.proxy.Proxy 类的字节码；</li>
<li>步骤 2：通过 com.sun.proxy.Proxy 类的字节码生成 com.sun.proxy.Proxy 类对应的 Class 类实例；</li>
<li>步骤 3：通过上述 Class 实例得到入口参数类型为 InvocationHandler 实例的构造器 Constructor 实例；</li>
<li>步骤 4：通过 Constructor 实例的 <code>newInstance()</code> 方法，输入我们自己写的 InvocationHandler 实例，利用反射机制最终构造出 com.sun.proxy.Proxy 类实例，因为没有在磁盘上的 class 文件，即作为匿名内部类存在，因此通常类型命名为：com.sun.proxy.$Proxy0，末尾的是序号，随着匿名内部类的增多序号自增；</li>
</ul>
<p>上述过程发生的方法栈如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//java.lang.reflect.Proxy#newProxyInstance
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">static</span> <span class="n">Object</span> <span class="nf">newProxyInstance</span><span class="o">(</span><span class="n">ClassLoader</span> <span class="n">loader</span><span class="o">,</span>
                                      <span class="n">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">interfaces</span><span class="o">,</span>
                                      <span class="n">InvocationHandler</span> <span class="n">h</span><span class="o">)</span>
  <span class="kd">throws</span> <span class="n">IllegalArgumentException</span>
<span class="o">{</span>	
  <span class="n">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">h</span><span class="o">);</span><span class="c1">//非空检查
</span><span class="c1"></span>
  <span class="kd">final</span> <span class="n">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">intfs</span> <span class="o">=</span> <span class="n">interfaces</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span><span class="c1">//克隆数组
</span><span class="c1"></span>  <span class="kd">final</span> <span class="n">SecurityManager</span> <span class="n">sm</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">getSecurityManager</span><span class="o">();</span><span class="c1">//安全检查
</span><span class="c1"></span>  <span class="k">if</span> <span class="o">(</span><span class="n">sm</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">checkProxyAccess</span><span class="o">(</span><span class="n">Reflection</span><span class="o">.</span><span class="na">getCallerClass</span><span class="o">(),</span> <span class="n">loader</span><span class="o">,</span> <span class="n">intfs</span><span class="o">);</span>
  <span class="o">}</span>
	<span class="c1">//这里生成代理类对应的 Class 类实例，这是最关键的一步，内部实现了步骤 1、2
</span><span class="c1"></span>  <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">cl</span> <span class="o">=</span> <span class="n">getProxyClass0</span><span class="o">(</span><span class="n">loader</span><span class="o">,</span> <span class="n">intfs</span><span class="o">);</span>

  <span class="k">try</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">sm</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">checkNewProxyPermission</span><span class="o">(</span><span class="n">Reflection</span><span class="o">.</span><span class="na">getCallerClass</span><span class="o">(),</span> <span class="n">cl</span><span class="o">);</span>
    <span class="o">}</span>
		<span class="c1">// 步骤 3
</span><span class="c1"></span>    <span class="kd">final</span> <span class="n">Constructor</span><span class="o">&lt;?&gt;</span> <span class="n">cons</span> <span class="o">=</span> <span class="n">cl</span><span class="o">.</span><span class="na">getConstructor</span><span class="o">(</span><span class="n">constructorParams</span><span class="o">);</span>
    <span class="c1">// 生成代理类的实例并把 InvocationHandler 实例传给它的构造方法  
</span><span class="c1"></span>    <span class="kd">final</span> <span class="n">InvocationHandler</span> <span class="n">ih</span> <span class="o">=</span> <span class="n">h</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">Modifier</span><span class="o">.</span><span class="na">isPublic</span><span class="o">(</span><span class="n">cl</span><span class="o">.</span><span class="na">getModifiers</span><span class="o">()))</span> <span class="o">{</span>
      <span class="n">AccessController</span><span class="o">.</span><span class="na">doPrivileged</span><span class="o">(</span><span class="k">new</span> <span class="n">PrivilegedAction</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;()</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="n">Void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
          <span class="n">cons</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
          <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
      <span class="o">});</span>
    <span class="o">}</span>
    <span class="c1">//步骤 4
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">cons</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="k">new</span> <span class="n">Object</span><span class="o">[]{</span><span class="n">h</span><span class="o">});</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IllegalAccessException</span><span class="o">|</span><span class="n">InstantiationException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="n">InternalError</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">toString</span><span class="o">(),</span> <span class="n">e</span><span class="o">);</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InvocationTargetException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Throwable</span> <span class="n">t</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getCause</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="k">instanceof</span> <span class="n">RuntimeException</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="o">(</span><span class="n">RuntimeException</span><span class="o">)</span> <span class="n">t</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="n">InternalError</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">toString</span><span class="o">(),</span> <span class="n">t</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">NoSuchMethodException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="n">InternalError</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">toString</span><span class="o">(),</span> <span class="n">e</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>步骤 1、2 发生于如下方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">getProxyClass0</span><span class="o">(</span><span class="n">ClassLoader</span> <span class="n">loader</span><span class="o">,</span>
                                       <span class="n">Class</span><span class="o">&lt;?&gt;...</span> <span class="n">interfaces</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">//检查传入的接口数是否大于 65535，接口数过多则直接抛出异常
</span><span class="c1"></span>  <span class="k">if</span> <span class="o">(</span><span class="n">interfaces</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="n">65535</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&#34;interface limit exceeded&#34;</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="c1">//根据给定的 interfaces 来生成 Proxy 类，这个方法首先去缓存中查找是否已经构造了 Proxy 实例
</span><span class="c1"></span>  <span class="c1">//如果还没有构造，那么就通过 ProxyClassFactory 来构造实例 
</span><span class="c1"></span>  <span class="k">return</span> <span class="n">proxyClassCache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">loader</span><span class="o">,</span> <span class="n">interfaces</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在 <code>proxyClassCache.get(loader, interfaces);</code> 方法执行过程中分为如下几步：</p>
<ul>
<li>通过注入类加载器、接口 interfaces 初始化 WeakCache.Factory 工厂实例；</li>
<li>利用工厂实例类动态生成一个类型为 com.sun.proxy.$Proxy 的字节码 <code>byte[]</code>；</li>
<li>利用字节码构造 com.sun.proxy.$Proxy 类实例；</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//java.lang.reflect.Proxy.ProxyClassFactory#apply
</span><span class="c1"></span><span class="nd">@Override</span>
<span class="kd">public</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">apply</span><span class="o">(</span><span class="n">ClassLoader</span> <span class="n">loader</span><span class="o">,</span> <span class="n">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">interfaces</span><span class="o">)</span> <span class="o">{</span>

  <span class="n">Map</span><span class="o">&lt;</span><span class="n">Class</span><span class="o">&lt;?&gt;,</span> <span class="n">Boolean</span><span class="o">&gt;</span> <span class="n">interfaceSet</span> <span class="o">=</span> <span class="k">new</span> <span class="n">IdentityHashMap</span><span class="o">&lt;&gt;(</span><span class="n">interfaces</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
  <span class="c1">//遍历我们输入的 interfaces 接口数组
</span><span class="c1"></span>  <span class="k">for</span> <span class="o">(</span><span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">intf</span> <span class="o">:</span> <span class="n">interfaces</span><span class="o">)</span> <span class="o">{</span>
		<span class="c1">//这里在检查每一个 interface 通过输入的类加载器加载后和原来的接口是否是同一个类
</span><span class="c1"></span>    <span class="c1">//因为 Java 的类加载机制有命名空间 NameSpace 机制
</span><span class="c1"></span>    <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">interfaceClass</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="n">interfaceClass</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="n">intf</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="kc">false</span><span class="o">,</span> <span class="n">loader</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ClassNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">interfaceClass</span> <span class="o">!=</span> <span class="n">intf</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span>
        <span class="n">intf</span> <span class="o">+</span> <span class="s">&#34; is not visible from class loader&#34;</span><span class="o">);</span>
    <span class="o">}</span>
		<span class="c1">//因为 interfaces 的元素类型是 Class，这里需要检查 Class 是否真的是指向接口而不是一般类
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(!</span><span class="n">interfaceClass</span><span class="o">.</span><span class="na">isInterface</span><span class="o">())</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span>
        <span class="n">interfaceClass</span><span class="o">.</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&#34; is not an interface&#34;</span><span class="o">);</span>
    <span class="o">}</span>
		<span class="c1">//利用 Set 来确保 interfaces 内没有放置重复的接口类型实例
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">interfaceSet</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">interfaceClass</span><span class="o">,</span> <span class="n">Boolean</span><span class="o">.</span><span class="na">TRUE</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span>
        <span class="s">&#34;repeated interface: &#34;</span> <span class="o">+</span> <span class="n">interfaceClass</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
  <span class="o">}</span>
	
  <span class="n">String</span> <span class="n">proxyPkg</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>     <span class="c1">// package to define proxy class in
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">accessFlags</span> <span class="o">=</span> <span class="n">Modifier</span><span class="o">.</span><span class="na">PUBLIC</span> <span class="o">|</span> <span class="n">Modifier</span><span class="o">.</span><span class="na">FINAL</span><span class="o">;</span>
	<span class="c1">//检查 Proxy 类的 package 管理的相关机制（不是重点）
</span><span class="c1"></span>  <span class="k">for</span> <span class="o">(</span><span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">intf</span> <span class="o">:</span> <span class="n">interfaces</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">intf</span><span class="o">.</span><span class="na">getModifiers</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">Modifier</span><span class="o">.</span><span class="na">isPublic</span><span class="o">(</span><span class="n">flags</span><span class="o">))</span> <span class="o">{</span>
      <span class="n">accessFlags</span> <span class="o">=</span> <span class="n">Modifier</span><span class="o">.</span><span class="na">FINAL</span><span class="o">;</span>
      <span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">intf</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
      <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="na">lastIndexOf</span><span class="o">(</span><span class="sc">&#39;.&#39;</span><span class="o">);</span>
      <span class="n">String</span> <span class="n">pkg</span> <span class="o">=</span> <span class="o">((</span><span class="n">n</span> <span class="o">==</span> <span class="o">-</span><span class="n">1</span><span class="o">)</span> <span class="o">?</span> <span class="s">&#34;&#34;</span> <span class="o">:</span> <span class="n">name</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">n</span> <span class="o">+</span> <span class="n">1</span><span class="o">));</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">proxyPkg</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">proxyPkg</span> <span class="o">=</span> <span class="n">pkg</span><span class="o">;</span>
      <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(!</span><span class="n">pkg</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">proxyPkg</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span>
          <span class="s">&#34;non-public interfaces from different packages&#34;</span><span class="o">);</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">proxyPkg</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 如果没有公开的代理接口，使用com.sun.proxy包
</span><span class="c1"></span>    <span class="n">proxyPkg</span> <span class="o">=</span> <span class="n">ReflectUtil</span><span class="o">.</span><span class="na">PROXY_PACKAGE</span> <span class="o">+</span> <span class="s">&#34;.&#34;</span><span class="o">;</span>
  <span class="o">}</span>

	<span class="c1">//生成 Proxy 类的类名称
</span><span class="c1"></span>  <span class="kt">long</span> <span class="n">num</span> <span class="o">=</span> <span class="n">nextUniqueNumber</span><span class="o">.</span><span class="na">getAndIncrement</span><span class="o">();</span>
  <span class="n">String</span> <span class="n">proxyName</span> <span class="o">=</span> <span class="n">proxyPkg</span> <span class="o">+</span> <span class="n">proxyClassNamePrefix</span> <span class="o">+</span> <span class="n">num</span><span class="o">;</span>

	<span class="c1">//这里开始是重点
</span><span class="c1"></span>  <span class="c1">//输入值依次为：生成的代理类的类名、接口、public final 修饰标记，用于生成代理类的字节码
</span><span class="c1"></span>  <span class="kt">byte</span><span class="o">[]</span> <span class="n">proxyClassFile</span> <span class="o">=</span> <span class="n">ProxyGenerator</span><span class="o">.</span><span class="na">generateProxyClass</span><span class="o">(</span>
    <span class="n">proxyName</span><span class="o">,</span> <span class="n">interfaces</span><span class="o">,</span> <span class="n">accessFlags</span><span class="o">);</span>
  <span class="k">try</span> <span class="o">{</span>
    <span class="c1">//利用字节码 byte[] 数组直接生成 Proxy 类实例
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">defineClass0</span><span class="o">(</span><span class="n">loader</span><span class="o">,</span> <span class="n">proxyName</span><span class="o">,</span>
                        <span class="n">proxyClassFile</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">proxyClassFile</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ClassFormatError</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><hr>
<p>如果你觉得代码太长，不妨先看一下这张执行流程图：</p>
<p><img src="../../../images/img_java/image-20200717120817196.png" alt="image-20200717120817196" style="zoom: 25%;" /></p>
<p>这里有几个小问题需要解决：</p>
<ul>
<li>
<p><strong>为什么构造 Proxy 匿名内部类的字节码输入不需要 Proxy 类呢？</strong></p>
<p>这是因为无论是 Proxy.ProxyClassFactory 还是 Proxy.defineClass0() 方法它们都知道你要构造 Proxy 的匿名内部类，这是写死的，因此我们并不需要再输入 Proxy 的 Class 对象；</p>
</li>
<li>
<p><strong>为什么 JDK 的动态代理仅仅支持接口而不支持继承呢？</strong></p>
<p>虽然继承和接口在利用多态实现动态代理没有太大的区别，但是 Java 是一门仅仅支持单一继承的语言，而所有 Proxy 匿名内部类都是 Proxy 类的子类（这是匿名内部类的定义要求之一），即动态代理类默认继承 com.sun.Proxy 类，因此无法基于继承实现动态代理。</p>
</li>
<li>
<p><strong>为什么动态代理的方法体不能进行 Debug？</strong></p>
<p>动态代理类都是匿名内部类，没有 .java 文件，也没有 Class 文件，而 IDE 的 Debug 模式依赖于行号，连文件都没有哪来行号，因此不能 Debug。当然你能对 InvocationHandler 的 <code>invoke()</code> 方法进行 debug，我指的是你无法利用 debug 来测试 <code>invoke()</code> 方法是如何被调用的。</p>
</li>
</ul>
<hr>
<p><strong>那么作为 Proxy 子类的（匿名内部类）的代理类是如何调用 InvocationHandler 的 <code>invoke()</code> 方法的呢？</strong></p>
<p>我们无法通过 debug 来观察 InvocationHandler 如何被调用，但是可以通过将匿名内部类的 Class 文件保存于硬盘，然后利用反编译软件来查看其实现机理。</p>
<blockquote>
<p>如何将 Class 文件保存于硬盘于见此章节末尾的 GitHub 项目地址，本节的所有代码也都放在此目录下。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//反编译文件
</span><span class="c1"></span><span class="kn">package</span> <span class="nn">com.sun.proxy</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.lang.reflect.InvocationHandler</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Method</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Proxy</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.UndeclaredThrowableException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">proxy.Foo</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">$Proxy0</span> <span class="kd">extends</span> <span class="n">Proxy</span> <span class="kd">implements</span> <span class="n">Foo</span> <span class="o">{</span>
   <span class="c1">//静态的 Method 实例，初始化写于类的最后
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Method</span> <span class="n">m1</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Method</span> <span class="n">m2</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Method</span> <span class="n">m3</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Method</span> <span class="n">m0</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">$Proxy0</span><span class="o">(</span><span class="n">InvocationHandler</span> <span class="n">var1</span><span class="o">)</span> <span class="kd">throws</span>  <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">var1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="n">Object</span> <span class="n">var1</span><span class="o">)</span> <span class="kd">throws</span>  <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">(</span><span class="n">Boolean</span><span class="o">)</span><span class="kd">super</span><span class="o">.</span><span class="na">h</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">m1</span><span class="o">,</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[]{</span><span class="n">var1</span><span class="o">});</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">RuntimeException</span> <span class="o">|</span> <span class="n">Error</span> <span class="n">var3</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="n">var3</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">var4</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">UndeclaredThrowableException</span><span class="o">(</span><span class="n">var4</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="kd">throws</span>  <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span><span class="kd">super</span><span class="o">.</span><span class="na">h</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">m2</span><span class="o">,</span> <span class="o">(</span><span class="n">Object</span><span class="o">[])</span><span class="kc">null</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">RuntimeException</span> <span class="o">|</span> <span class="n">Error</span> <span class="n">var2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="n">var2</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">var3</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">UndeclaredThrowableException</span><span class="o">(</span><span class="n">var3</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="n">String</span> <span class="nf">bar</span><span class="o">(</span><span class="n">String</span> <span class="n">var1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">var2</span><span class="o">)</span> <span class="kd">throws</span>  <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span><span class="kd">super</span><span class="o">.</span><span class="na">h</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">m3</span><span class="o">,</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[]{</span><span class="n">var1</span><span class="o">,</span> <span class="n">var2</span><span class="o">});</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">RuntimeException</span> <span class="o">|</span> <span class="n">Error</span> <span class="n">var4</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="n">var4</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">var5</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">UndeclaredThrowableException</span><span class="o">(</span><span class="n">var5</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="kd">throws</span>  <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">(</span><span class="n">Integer</span><span class="o">)</span><span class="kd">super</span><span class="o">.</span><span class="na">h</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">m0</span><span class="o">,</span> <span class="o">(</span><span class="n">Object</span><span class="o">[])</span><span class="kc">null</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">RuntimeException</span> <span class="o">|</span> <span class="n">Error</span> <span class="n">var2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="n">var2</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">var3</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">UndeclaredThrowableException</span><span class="o">(</span><span class="n">var3</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
		<span class="c1">//静态初始化逻辑
</span><span class="c1"></span>    <span class="kd">static</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">m1</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">&#34;java.lang.Object&#34;</span><span class="o">).</span><span class="na">getMethod</span><span class="o">(</span><span class="s">&#34;equals&#34;</span><span class="o">,</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">&#34;java.lang.Object&#34;</span><span class="o">));</span>
            <span class="n">m2</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">&#34;java.lang.Object&#34;</span><span class="o">).</span><span class="na">getMethod</span><span class="o">(</span><span class="s">&#34;toString&#34;</span><span class="o">);</span>
            <span class="n">m3</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">&#34;proxy.Foo&#34;</span><span class="o">).</span><span class="na">getMethod</span><span class="o">(</span><span class="s">&#34;bar&#34;</span><span class="o">,</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">&#34;java.lang.String&#34;</span><span class="o">),</span> <span class="n">Integer</span><span class="o">.</span><span class="na">TYPE</span><span class="o">);</span>
            <span class="n">m0</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">&#34;java.lang.Object&#34;</span><span class="o">).</span><span class="na">getMethod</span><span class="o">(</span><span class="s">&#34;hashCode&#34;</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">NoSuchMethodException</span> <span class="n">var2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">NoSuchMethodError</span><span class="o">(</span><span class="n">var2</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ClassNotFoundException</span> <span class="n">var3</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">NoClassDefFoundError</span><span class="o">(</span><span class="n">var3</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>通过上述反编译的匿名内部类代码，我们可以看出：</p>
<ul>
<li>
<p>匿名内部类对于方法 <code>equals()</code>、<code>toString()</code>、<code>hashCode()</code> 方法首先映射为 Object 的方法对应的 Method 实例，然后转发给 InvocationHandler 实例的 <code>invoke()</code> 方法。注意：其他方法（包括代理方法）都将代理类作为方法接受者，而不是 InvocationHandler 实例；</p>
<blockquote>
<p>比如说，即使你为 InvocationHandler 实例创建了多个代理类实例，但是它们的 <code>equals()</code> 方法返回 true，因为比较的是 InvocationHandler 实例，而不是代理类实例。这要求我们对 <code>InvocationHandler.invoke()</code> 进行此方法逻辑代码的处理。</p>
</blockquote>
</li>
<li>
<p>从匿名内部类的 <code>bar()</code> 方法可以看出，其除了捕获异常代码块，实际上就是直接简单地调用 InvocationHandler 实例的 <code>invoke()</code> 方法。</p>
<blockquote>
<p>而 <code>invoke()</code> 方法的逻辑通常是根据传入的 <code>Method method</code> 实例的类型来执行不同的逻辑，但是不需要每次调用都重新创建 Mehthod 实例（它们是静态字段，仅仅初始化一次），因此和普通方法调用相比，在执行效率上区别不大。</p>
</blockquote>
</li>
</ul>
<p>因此我们可以看到代理类的继承、实现、依赖关系如下图所示：</p>
<p><img src="../../../images/img_java/image-20200722211941730.png" alt="image-20200722211941730" style="zoom: 25%;" /></p>
<ul>
<li>Proxyee 为被代理类；</li>
<li>Proxyer 为代理类，负责代理逻辑的组织以及对外暴露 interfaces 接口方法；</li>
<li>InvocationHandler 为回调函数的方法，这里的回调函数即代理方法；</li>
</ul>
<p>最后总结一下，JDK 的动态代理简单明了，可以将其视作<strong>动态生成的</strong>匿名内部类版本的静态代理，但是在代理逻辑上和静态代理没有任何区别。其核心思想是基于接口 interfaces 以及 com.sun.proxy.Proxy 类动态新生成一个全新的代理类的字节码，然后基于字节码生成 Proxy 的匿名内部类。</p>
<p>接下来会看到 CGLIB 动态代理和 JDK 动态代理的主要区别就在于：</p>
<ul>
<li>JDK 是基于 com.sun.proxy.Proxy 类以及 interfaces 生成全新的字节码；</li>
<li>CGLIB 直接在原字节码上修改，因此无需依赖于接口；</li>
</ul>
<blockquote>
<p>补充：</p>
<ul>
<li>本文基于 JDK8 进行讲述；</li>
<li>具体的 JDK 动态代理源码分析，可见：https://www.iteye.com/blog/rejoy-1627405</li>
</ul>
</blockquote>
<h3 id="22-cglib-动态代理">2.2 CGLIB 动态代理</h3>
<blockquote>
<p>限于篇幅，CGLIB 动态代理不妨看我的另一篇文章：<a href="https://spongecaptain.cool/post/java/cglibproxy/">CGLIB 动态代理的实际演练</a></p>
</blockquote>
<h3 id="23-aspectj-动态代理">2.3 AspectJ 动态代理</h3>
<blockquote>
<p>限于篇幅，CGLIB 动态代理不妨看我的另一篇文章：<a href="https://spongecaptain.cool/post/java/aspectjproxy/">AspectJ 动态代理的实际演练</a></p>
</blockquote>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/java/">Java</a>
          <a href="/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">代理模式</a>
          <a href="/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/">动态代理</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/java/cglibproxy/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">CGLIB 动态代理的实际演练</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/java/refelectionsummary/">
            <span class="next-text nav-default">Java 反射小总结</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>


      <h3>转载申请</h3>
      <a rel=license href=https://creativecommons.org/licenses/by/4.0>
        <img alt=知识共享许可协议 style=border-width:0 src=../../static/creative-commons.png>
      </a>
      <br>本作品采用
      <a rel=license href=http://creativecommons.org/licenses/by/4.0/ target="_blank" style="text-decoration:underline;" >
      知识共享署名 4.0 国际许可协议</a>
      进行许可，转载时请注明作者姓名以及原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。

      
    </footer>
  </article>
        </div>
        <div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js" crossorigin="anonymous"></script>
    <script type="text/javascript">
      var gitalk = new Gitalk({
        id: '2020-07-22 20:56:48 \u002b0800 CST',
        title: 'Java 的代理模式的实现',
        clientID: 'b8e9909664fb69930809',
        clientSecret: '847d9069c9532ab260721afb9f036cdb8f52aec4',
        repo: 'Spongecaptain.github.io',
        owner: 'Spongecaptain',
        admin: ['Spongecaptain'],
        body: decodeURI(location.href)
      });
      gitalk.render('gitalk-container');
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/gitalk/gitalk">comments powered by gitalk.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:wjjiang19@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/spongecaptain" class="iconfont icon-github" title="github"></a>
  <a href="https://spongecaptain.cool/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2019 - 
    2022
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Spongecaptain</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.2517c0eb67172a0bae917de4af59b10ca2531411a009d4c0b82f5685259e5771.js"></script>








</body>
</html>
